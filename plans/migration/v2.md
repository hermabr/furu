# Full Complete Plan: Schema-Keyed Alias-Only Migration + Stored `schema_key`

This plan is a complete implementation of the schema-keyed alias-only migration plan. It references your actual files and constraints:

- `FuruMetadata` lives in `src/furu/storage/metadata.py` and has `extra="forbid"`
- Migration records are in `src/furu/storage/migration.py` (`.furu/migration.json`)
- Old migration logic is in `src/furu/migration.py` and wrapper in `src/furu/migrate.py`
- Alias behavior in runtime is implemented in `src/furu/core/furu.py`
- Dashboard scan logic is in `src/furu/dashboard/scanner.py` and models in `src/furu/dashboard/api/models.py`
- You don’t care about backwards compatibility and want to deprecate the existing migration logic

---

## 0) Target behavior (what the system should do)

### Core semantics

1. **Schema is top-level keys of `metadata["furu_obj"]`** only.
2. Ignore any keys starting with `_` (including `__class__`).
3. Do **not** include nested keys.
4. `schema_key` is stored in metadata as a **tuple of sorted unique keys**:
   - `schema_key = tuple(sorted(set(k for k in furu_obj.keys() if not k.startswith("_"))))`

5. Migration only supports **aliasing** (no move, no copy).
6. **Alias objects must point back to the original object** (alias → original pointer).
7. **Original object must expose a list of all aliases** (original → aliases list) via API + dashboard. (Implementation can derive this list by indexing alias records, but it must be exposed and correct.)

### Alias uniqueness constraint (important)

For a given original object (the “ultimate original” after flattening alias chains):

- You must NOT be able to create **two alias objects** with the same `schema_key`.
- If attempted, throw. This should not be overridable with environment variables or configuration flags.

### Stale objects (dashboard + API)

- “Current schema” for a class is derived from the **Python class fields** (top-level only; ignore underscore-prefixed fields).
- The dashboard should primarily show objects matching the current schema.
- The API should also provide the objects that do **not** match current schema (“stale”).
- Also expose whether an object is an alias and alias relationships.

---

## 1) Data model changes

### 1.1 Add `schema_key` to metadata (stored)

File: `src/furu/storage/metadata.py`

- Update the Pydantic model `FuruMetadata` to include:
  - `schema_key: tuple[str, ...]`

Because the model currently uses `ConfigDict(extra="forbid", strict=True)`, you must add the field explicitly or metadata writes/reads will break.

Naming: user wants it called `schema_key` — do that. (Avoid `schema_version` to prevent confusion with existing `furu_version`.)

### 1.2 Compute `schema_key` when writing metadata

File: `src/furu/storage/metadata.py` in `MetadataManager.create_metadata(...)`

- After computing `furu_obj = FuruSerializer.to_dict(obj)` (already done), compute:
  - if `furu_obj` is a dict:
    - `schema_key = tuple(sorted({k for k in furu_obj.keys() if not k.startswith("_")}))`

  - else:
    - schema_key should be `()` (or throw; but practically furu_obj should always be dict for Furu objects)

- Include `schema_key` in the returned `FuruMetadata`.

---

## 2) Canonical schema helpers (single source of truth)

Create a small helper module used by:

- metadata writing
- migration selection
- dashboard staleness checks

Suggested file: `src/furu/schema.py`

### 2.1 Functions

- `schema_key_from_furu_obj(furu_obj: dict[str, object]) -> tuple[str, ...]`
- `schema_key_from_metadata_raw(metadata: dict[str, object]) -> tuple[str, ...]`
  - Prefer reading `metadata["schema_key"]`, it should always be present. If not, throw.

- `schema_key_from_cls(cls: type[Furu]) -> tuple[str, ...]`
  - Use `chz.chz_fields(cls)` (or whatever you already use) to get top-level field names
  - Ignore field names starting with `_`
  - Return sorted tuple

---

## 3) Alias model: must be bidirectional (alias → original AND original → aliases)

### 3.1 Alias → original (already exists; keep it)

Your current alias mechanism uses `MigrationRecord` in `.furu/migration.json` in the alias directory:

- `kind == "alias"`
- `from_*` identifies original object
- `to_*` identifies alias object
- `overwritten_at` marks inactive/detached alias

This already satisfies **alias points back to original**. Keep it.

### 3.2 Original → aliases list (must be exposed)

You already have the _indexing mechanism_ in the dashboard scanner:

- `_collect_aliases()` in `src/furu/dashboard/scanner.py` builds:
  - key = `(from_namespace, from_hash, from_root)`
  - value = list of alias migration records

This is perfect as the authoritative source of **original → aliases list**.

#### Required upgrade

Currently `_collect_aliases()` filters out overwritten aliases (`if migration.overwritten_at is not None: continue`).
You said you want “original has a list of all alias objects”. That implies:

- include overwritten aliases too, but expose whether they’re active.

So change alias collection to return **all alias records**, and each record should include `overwritten_at` so callers can determine active/inactive.

Concretely:

- Remove the filter `if migration.overwritten_at is not None: continue`
- Or provide two modes:
  - `include_inactive=False` (current behavior)
  - `include_inactive=True` (new behavior for “all aliases”)

Then:

- For dashboard summaries/details:
  - provide `aliases: [{to_hash, to_namespace, overwritten_at, migrated_at, ...}]`
  - also provide `active_aliases` if you still want the old behavior

This satisfies the requirement without introducing a second “alias index file” that can get out of sync.

---

## 4) Deprecate existing migration logic (no backward compatibility)

### 4.1 Remove/stop using the old candidate-based API

Current old code:

- `src/furu/migration.py` (complex candidate matching + move/copy)
- `src/furu/migrate.py` (wrapper)

Plan:

- Rename old logic to `migration_legacy.py` (optional), or delete it.
- Rewrite `src/furu/migration.py` with the new schema-key migration system.
- Rewrite `src/furu/migrate.py` into a thin wrapper (optional) or remove it from public exports in `src/furu/__init__.py`.

Given you don’t care about backwards compatibility, it’s fine to break/remove:

- `find_migration_candidates_*`
- move/copy policies
- drop_fields/default_fields behavior tied to the old matching model

---

## 5) New migration system: schema-keyed, alias-only

### 5.1 What “migration” means now

A migration creates a **new Furu object config** (new `furu_obj`) and then uses **alias policy** to “link” it to an existing successful original artifact.

- alias directory (new hash) is created
- it stores metadata for the new config (including new `schema_key`)
- it stores a migration record pointing back to original (so `.get()` resolves to original artifact)
- it stores migrated state marker (like current alias behavior)

### 5.2 Candidate selection is schema-key based

Source selection should support:

1. **By schema_key**:
   - User provides `from_schema: tuple[str, ...]` (or list/iterable → normalized to tuple)
   - Select all objects in a namespace where `metadata.schema_key == from_schema`

2. **By specific object**:
   - `from_hash="..."` (namespace implied by target class unless overridden)
   - OR `from_furu_obj={...}` (compute hash and resolve)
   - OR `from_dir=Path(...)` (optional, internal)

3. Optional:
   - `include_alias_sources: bool` (default False)
     - If False: only treat “real” objects as sources
     - If True: allow migrating from alias dirs too, but flatten to original (see below)

### 5.3 Alias-chain flattening

If the selected source is already an alias:

- resolve it to the **ultimate original** using migration records (follow `kind=="alias"` through `from_*` pointers)
- this resolved original is the identity for:
  - uniqueness checks
  - alias record `from_*`
  - alias list in dashboard

### 5.4 Transform spec (field ops you want)

Migration must support these operations:

- `default_field: Iterable[str]`
  - For each field in `default_field`:
    - if missing in source furu_obj, set it using the target class default value
    - error if target class has no default

- `set_field: Mapping[str, Any]`
  - For each key/value:
    - if key missing, set it to that value
    - by default: error if key already exists unless `allow_overwrite=True`

- `drop_field: Iterable[str]`
  - remove these keys if present (or error if not present; pick strictness; recommend strict for safety)

- `rename_field: Mapping[str, str]`
  - for each old→new:
    - require old exists
    - require new does not exist (unless allow_overwrite)
    - move value

Order of application (deterministic):

1. rename_field
2. drop_field
3. default_field
4. set_field

### 5.5 Validation

After transform:

- instantiate target class via `FuruSerializer.from_dict(new_furu_obj_dict)`
  - this ensures:
    - required keys exist (or defaults apply)
    - no unknown fields

- types are whatever your serializer enforces; schema matching itself ignores types, but instantiation must work.

### 5.6 Your migrate_to (“describe backwards”) use case

Support the pattern:

> “I added a new required field `language`, so I can’t instantiate old objects anymore; migrate old schema to new schema.”

API should allow deriving the source schema by removing fields from the _current_ schema:

- `from_drop=("language",)` means:
  - `from_schema = cls.schema_key() - {"language"}`

And then apply:

- `set_field={"language":"fr"}` or `default_field=("language",)` if default exists

This is the cleanest way to express `migrate_to(MyObj(..., language="fr"), drop_field="language")` without needing to create the “old” object.

---

## 6) Public APIs (Python) — simple + powerful

Implement as **classmethods on `Furu`** (file: `src/furu/core/furu.py`).

### 6.1 Schema APIs

- `@classmethod def schema_key(cls) -> tuple[str, ...]`
  - computed from class fields (ignore underscore fields)

Optional:

- `def schema_key(self) -> tuple[str, ...]`
  - same as class schema (or derive from `FuruSerializer.to_dict(self)`)

### 6.2 Migration API (primary)

Add:

```
@classmethod
def migrate(
    cls,
    *,
    # source selection
    from_schema: Iterable[str] | None = None,
    from_drop: Iterable[str] | None = None,    # derive from current schema (migrate_to style)
    from_add: Iterable[str] | None = None,     # optional

    from_hash: str | None = None,
    from_furu_obj: dict[str, object] | None = None,
    from_namespace: str | None = None,         # default: cls namespace

    # transform
    default_field: Iterable[str] | None = None,
    set_field: Mapping[str, object] | None = None,
    drop_field: Iterable[str] | None = None,
    rename_field: Mapping[str, str] | None = None,

    # behavior
    include_alias_sources: bool = False,
    conflict: Literal["throw", "skip"] = "throw",
    origin: str | None = None,
    note: str | None = None,
) -> MigrationReport
```

Rules:

- Exactly one of `{from_schema, from_hash, from_furu_obj, (from_drop/from_add)}` should be enough to define the source set.
- If multiple are provided, define precedence and validate (recommend: error on ambiguous combinations).

### 6.3 Migration convenience APIs

Add:

- `@classmethod def migrate_one(cls, *, from_hash: str, ...) -> MigrationRecord | None`
- `@classmethod def stale(cls, *, namespace: str | None = None) -> list[FuruRef]`
  - finds stored objects in that namespace whose `metadata.schema_key != cls.schema_key()`

- `@classmethod def current(cls, *, namespace: str | None = None) -> list[FuruRef]`

### 6.4 Alias relationship APIs

On a `Furu` instance:

- `def is_alias(self) -> bool`
  - checks if its base dir has `migration.kind == "alias"` and record is active (or just exists)

- `def original(self) -> FuruRef`
  - if alias: resolve to ultimate original ref
  - else: return self ref

- `def aliases(self, *, include_inactive: bool = True) -> list[FuruRef]`
  - only meaningful on original; uses alias-indexing (same logic as dashboard)
  - returns alias refs for which `migration.from_hash == self.original().hash`

(Implementation can share code with the dashboard scanner’s alias collector.)

---

## 7) Alias uniqueness guard (must throw)

When migrating (creating a new alias object):

- compute target `schema_key` (it will be `cls.schema_key()` after transform/validation)
- resolve original ref (`orig = resolve_original(from_ref)`)
- check all existing aliases for this `orig`:
  - if any alias has `metadata.schema_key == target_schema_key` → conflict
  - if `conflict == "throw"` → raise
  - if `conflict == "skip"` → report skip

How to check existing aliases efficiently:

- Use the same indexing logic as dashboard:
  - scan migration records in namespace/root, build mapping from `(from_namespace, from_hash, from_root)` → alias records
  - optionally cache during a migration run

---

## 8) Dashboard + API: expose schema + staleness + alias info

### 8.1 Update API models

File: `src/furu/dashboard/api/models.py`

Add fields to `ExperimentSummary` and `ExperimentDetail`:

- `schema_key: list[str] | None`
  (JSON doesn’t have tuple; frontend sees list. Backend uses tuple.)
- `current_schema_key: list[str] | None`
- `is_stale: bool | None`
- `is_alias: bool | None`
- `original_namespace: str | None` / `original_hash: str | None` (already present in detail; you can add to summary too)
- `alias_hashes: list[str] | None` should become:
  - either **all aliases** (include inactive) + `alias_overwritten_at` info
  - or provide `aliases: list[{hash, overwritten_at, migrated_at}]`

### 8.2 Update scanner to use stored `schema_key`

File: `src/furu/dashboard/scanner.py`

When reading metadata for each experiment:

- Prefer `schema_key` from metadata directly.
- If missing, compute from `furu_obj` as fallback (optional; since no backwards compat, you may omit fallback).

Compute current schema for a namespace:

- Attempt to import the class (you already have namespace strings)
- Compute `current_schema_key = schema_key_from_cls(cls)`
- Compare to stored schema_key → `is_stale`

Filtering:

- Default dashboard listing should show only `is_stale == False` (current schema).
- Add query params to list stale:
  - `schema=current|stale|any` (server-side filtering)

### 8.3 Alias exposure in dashboard

You already return `alias_hashes` in `get_experiment_detail` via `_alias_reference`.

Update to:

- return **all aliases** for an original (not only active), and include active/inactive status (`overwritten_at`).

---

## 9) Tests (replace old migration tests)

Since you don’t care about backward compatibility:

- remove/update tests that assert move/copy behavior
- focus on the new invariants:

1. `schema_key` is stored in metadata and computed correctly:
   - underscore keys excluded
   - top-level only
   - stable ordering

2. Migration by schema:
   - create data under old schema, run `NewCls.migrate(from_schema=old_schema, default_field=..., set_field=...)`
   - verify alias directories are created and `.get()` resolves to original artifact

3. `rename_field` / `drop_field` behaviors

4. Uniqueness guard:
   - attempt to create second alias for same original + same schema_key → must throw

5. Alias chain flattening:
   - alias from alias still points to ultimate original

6. Dashboard staleness:
   - API returns `current` vs `stale` correctly using stored schema_key

---

## 10) One final naming note

You want the field named **`schema_key`**. That works well.

Just be aware:

- `FuruMetadata` currently includes `furu_version` (package version), so avoid naming it `schema_version` to prevent confusion.
- Keep it `schema_key` everywhere: metadata field, API field, dashboard UI.
